"use strict";(self.webpackChunkglitch_runner=self.webpackChunkglitch_runner||[]).push([[4606],{8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var i=n(6540);const r={},o=i.createContext(r);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:t},e.children)}},9647:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"leetcode-cpp/leetcode","title":"Leetcode problems in C++","description":"Let\'s solve Leetcode problems","source":"@site/docs/leetcode-cpp/leetcode.md","sourceDirName":"leetcode-cpp","slug":"/leetcode","permalink":"/glitch-runner/docs/leetcode","draft":false,"unlisted":false,"editUrl":"https://github.com/cosmoglitch/glitch-runner/docs/leetcode-cpp/leetcode.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Leetcode Problems","id":"leetcode","title":"Leetcode problems in C++","slug":"/leetcode","description":"Let\'s solve Leetcode problems"},"sidebar":"tutorialSidebar","previous":{"title":"Leetcode-CPP","permalink":"/glitch-runner/docs/category/leetcode-cpp"},"next":{"title":"Tutorial - Basics","permalink":"/glitch-runner/docs/category/tutorial---basics"}}');var r=n(4848),o=n(8453);const s={sidebar_label:"Leetcode Problems",id:"leetcode",title:"Leetcode problems in C++",slug:"/leetcode",description:"Let's solve Leetcode problems"},c=void 0,d={},l=[{value:"1. Two Sum",id:"1-two-sum",level:2}];function a(e){const t={blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"1-two-sum",children:"1. Two Sum"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1]."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Approach"})})," :\nWe will loop through the array once. And add the visited umber and its index to a Map."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'With every index in loop, we will fetch the number and find the difference from "target".'}),"\n",(0,r.jsx)(t.li,{children:"If the difference has already been visited in the array, then we return the current index and the index of the visited number."}),"\n",(0,r.jsx)(t.li,{children:"Else we add the visited number and index to the Map and move along."}),"\n",(0,r.jsxs)(t.li,{children:["At the end if no 2 numbers satisfy the condition, we send ",-1]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n\n        unordered_map<int, int> visitedMapList;\n\n        for (int i = 0; i<nums.size(); i++) {\n            int difference = target - nums[i];\n\n            if (visitedMapList.find(difference) != visitedMapList.end()) {\n                return {visitedMapList[target-nums[i]], i};\n            }\n\n            visitedMapList[nums[i]] = i;\n        }\n\n        return {-1,-1};\n    }\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Space Complexity"})," : O(n)"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Time Complexity"}),"  : O(n)"]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);